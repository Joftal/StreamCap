name: Dev Build

on:
  push:
    branches:
      - dev
  workflow_dispatch:

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Create logger_fix.py for GUI mode
        shell: pwsh
        run: |
          # 创建logger_fix.py文件内容
          $content = @'
import os
import sys
import re

from loguru import logger

script_path = os.path.split(os.path.realpath(sys.argv[0]))[0]

# 添加内存清理日志过滤器
def is_memory_cleanup_log(record):
    """检查是否为内存清理相关的日志"""
    message = record["message"]
    memory_cleanup_patterns = [
        r"执行轻量级清理任务",
        r"执行完整清理任务",
        r"轻量级清理",
        r"完整清理",
        r"内存使用率过高",
        r"内存使用详情",
        r"系统统计",
        r"开始执行完整清理",
        r"内存使用率:",
        r"实例清理",
        r"实例统计",
        r"实例管理",
        # 测试脚本中使用的内存相关日志模式
        r"开始内存测试",
        r"内存状态",
        r"创建实例",
        r"内存测试总结",
        r"主动触发垃圾回收",
        r"显式清理未使用的实例",
        r"等待.*秒让自动清理机制工作",
        r"清理实例后",
        r"开始内存优化测试"
    ]
    return any(re.search(pattern, message) for pattern in memory_cleanup_patterns)

# 添加一个普通日志的过滤器
def not_memory_cleanup_log(record):
    return not is_memory_cleanup_log(record)

# 确保日志目录存在
os.makedirs(f"{script_path}/logs", exist_ok=True)

# 检查是否为GUI模式（没有控制台）
is_gui_mode = False
try:
    # 尝试写入stderr，如果失败则认为是GUI模式
    sys.stderr.write("")
except Exception:
    is_gui_mode = True

# 根据模式选择日志配置
if not is_gui_mode:
    # 控制台模式：添加控制台输出处理器
    logger.add(
        sys.stderr,
        level="DEBUG",
        format="{time:YYYY-MM-DD HH:mm:ss.SSS} | {level: <8} | {message}",
        enqueue=True,
    )
else:
    # GUI模式：添加内存清理日志文件处理器
    logger.add(
        f"{script_path}/logs/memory_clean.log",
        level="DEBUG",
        format="{time:YYYY-MM-DD HH:mm:ss.SSS} | {level: <8} | {name}:{function}:{line} - {message}",
        filter=lambda i: is_memory_cleanup_log(i),
        serialize=False,
        enqueue=True,
        retention=3,
        rotation="3 MB",
        encoding="utf-8",
    )

# 无论何种模式，都添加文件日志处理器
# 文件日志处理器，排除内存清理日志
logger.add(
    f"{script_path}/logs/streamget.log",
    level="DEBUG",
    format="{time:YYYY-MM-DD HH:mm:ss.SSS} | {level: <8} | {name}:{function}:{line} - {message}",
    filter=lambda i: not_memory_cleanup_log(i) and i["level"].name != "STREAM",
    serialize=False,
    enqueue=True,
    retention=3,
    rotation="3 MB",
    encoding="utf-8",
)

logger.level("STREAM", no=22, color="<blue>")
logger.add(
    f"{script_path}/logs/play_url.log",
    level="STREAM",
    format="{time:YYYY-MM-DD HH:mm:ss.SSS} | {message}",
    filter=lambda i: i["level"].name == "STREAM",
    serialize=False,
    enqueue=True,
    retention=1,
    rotation="500 KB",
    encoding="utf-8",
)
'@

          # 创建app/utils目录（如果不存在）
          New-Item -ItemType Directory -Force -Path "app\utils" | Out-Null
          # 写入logger_fix.py文件
          Set-Content -Path "app\utils\logger_fix.py" -Value $content
          Write-Host "Created logger_fix.py for GUI mode"

      - name: Apply logger fix
        run: |
          # 备份原始logger.py
          if (Test-Path -Path "app\utils\logger.py") {
            Copy-Item -Path "app\utils\logger.py" -Destination "app\utils\logger.py.bak" -Force
            Write-Host "Backed up original logger.py"
          }
          
          # 应用修复版本
          Copy-Item -Path "app\utils\logger_fix.py" -Destination "app\utils\logger.py" -Force
          Write-Host "Applied logger fix for GUI mode"

      - name: Build Windows executable (GUI mode)
        run: |
          # 确保所需文件夹存在
          foreach ($folder in @("assets", "config", "downloads", "locales", "logs")) {
            if (-not (Test-Path -Path $folder)) {
              New-Item -ItemType Directory -Force -Path $folder | Out-Null
              Write-Host "Created folder: $folder"
            }
          }
          
          # 使用PyInstaller构建GUI模式可执行文件
          pyinstaller --name StreamCap --windowed --icon=assets/icon.ico main.py
          
          Write-Host "Built StreamCap in GUI mode"
          
          # 复制所需文件夹到dist\StreamCap目录
          foreach ($folder in @("assets", "config", "downloads", "locales", "logs")) {
            if (-not (Test-Path -Path "dist\StreamCap\$folder")) {
              Copy-Item -Path $folder -Destination "dist\StreamCap\" -Recurse -Force
              Write-Host "Copied folder: $folder to dist\StreamCap\"
            }
          }

      - name: Debug directory contents
        run: |
          Write-Host "dist\StreamCap directory structure:"
          Get-ChildItem -Path .\dist\StreamCap -Recurse -Depth 2 | Select-Object FullName

      - name: Create ZIP archive
        run: |
          # 压缩整个dist\StreamCap目录
          Compress-Archive -Path "dist\StreamCap\*" -DestinationPath "StreamCap-Windows.zip" -Force

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: StreamCap-Windows
          path: ./StreamCap-Windows.zip
          retention-days: 7 